<!DOCTYPE html>
<!--
  THIS IS NOT THE INTERESTING FILE

  This is just some UI code. There's nothing interesting and unique in this file. The interesting
  thing about this demo is the server side, which is in chat.mjs.

  WARNING: This was written by a systems engineer, not a web developer. It's probably bad.
-->

<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta charset="UTF-8">
    <title>Edge Chat Demo</title>
<!--===================================================================================-->
<!-- Inline style to avoid an extra round trip before the page can render. -->
<style type="text/css">
:root {
  --primary-color: #4f46e5;
  --primary-hover: #4338ca;
  --secondary-color: #f8fafc;
  --text-color: #1f2937;
  --text-light: #6b7280;
  --border-color: #e5e7eb;
  --border-focus: #3b82f6;
  --success-color: #10b981;
  --error-color: #ef4444;
  --warning-color: #f59e0b;
  --background: #ffffff;
  --chat-background: #f9fafb;
  --message-background: #ffffff;
  --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
}

* {
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  margin: 0;
  padding: 0;
  background: var(--background);
  color: var(--text-color);
  line-height: 1.5;
}

#chatlog {
  position: fixed;
  top: 0;
  bottom: 70px;
  left: 0;
  right: 250px;
  overflow-y: auto;
  padding: 20px;
  background: var(--chat-background);
  overflow-wrap: break-word;
  transition: top 0.3s ease;
}

#chatlog.with-room-info {
  top: 80px;
}

#chatlog p {
  background: var(--message-background);
  margin: 8px 0;
  padding: 12px 16px;
  border-radius: 12px;
  box-shadow: var(--shadow);
  animation: messageSlideIn 0.2s ease-out;
  transition: transform 0.1s ease;
}

#chatlog p:hover {
  transform: translateY(-1px);
}

@keyframes messageSlideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

#chatlog span.username {
  font-weight: 600;
  color: var(--primary-color);
  margin-right: 8px;
}

#spacer {
  height: calc(100vh - 70px - 5em);
}

#roster {
  position: fixed;
  right: 0;
  top: 0;
  bottom: 70px;
  width: 250px;
  background: var(--background);
  border-left: 1px solid var(--border-color);
  padding: 20px;
  overflow-y: auto;
}

#roster h3 {
  margin: 0 0 16px 0;
  color: var(--text-color);
  font-size: 18px;
  font-weight: 600;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--border-color);
}

#roster p {
  margin: 8px 0;
  padding: 8px 12px;
  background: var(--secondary-color);
  border-radius: 8px;
  font-weight: 500;
  color: var(--text-color);
  display: flex;
  align-items: center;
}

#roster p::before {
  content: "‚óè";
  color: var(--success-color);
  margin-right: 8px;
  font-size: 12px;
}

::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--text-light);
}

@media(max-width:768px) {
  #roster { 
    display: none; 
  }
  #chatlog { 
    right: 0; 
  }
}

#chat-input-container {
  position: fixed;
  width: 100%;
  height: 70px;
  bottom: 0;
  left: 0;
  background: var(--background);
  border-top: 1px solid var(--border-color);
  padding: 15px 20px;
  display: flex;
  align-items: center;
  gap: 12px;
  box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
}

#chat-input {
  flex: 1;
  height: 40px;
  border: 1px solid var(--border-color);
  border-radius: 20px;
  padding: 0 16px;
  outline: none;
  font-size: 14px;
  transition: all 0.2s ease;
  background: var(--background);
}

#chat-input:focus {
  border-color: var(--border-focus);
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

#send-button {
  width: 40px;
  height: 40px;
  background: var(--primary-color);
  border: none;
  border-radius: 20px;
  color: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  font-size: 16px;
}

#send-button:hover {
  background: var(--primary-hover);
  transform: scale(1.05);
}

#send-button:active {
  transform: scale(0.95);
}

#name-form {
  position: fixed;
  z-index: 1000;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(135deg, var(--primary-color), var(--primary-hover));
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

#name-form-content {
  background: var(--background);
  padding: 40px;
  border-radius: 16px;
  box-shadow: var(--shadow-lg);
  text-align: center;
  max-width: 400px;
  width: 90%;
}

#name-form h1 {
  margin: 0 0 24px 0;
  font-size: 28px;
  font-weight: 700;
  color: var(--text-color);
}

#name-input {
  width: 100%;
  height: 48px;
  font-size: 16px;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 0 16px;
  margin-bottom: 24px;
  text-align: center;
  outline: none;
  transition: all 0.2s ease;
}

#name-input:focus {
  border-color: var(--border-focus);
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

#name-form p {
  color: var(--text-light);
  font-size: 14px;
  line-height: 1.6;
  margin: 0;
}

#name-form a {
  color: var(--primary-color);
  text-decoration: none;
  font-weight: 500;
}

#name-form a:hover {
  text-decoration: underline;
}

#room-form {
  position: fixed;
  z-index: 999;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(135deg, var(--primary-color), var(--primary-hover));
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

#room-form-content {
  background: var(--background);
  padding: 40px;
  border-radius: 16px;
  box-shadow: var(--shadow-lg);
  text-align: center;
  max-width: 450px;
  width: 90%;
}

#room-form h2 {
  margin: 0 0 24px 0;
  font-size: 24px;
  font-weight: 600;
  color: var(--text-color);
}

#room-name {
  width: 100%;
  height: 48px;
  font-size: 16px;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 0 16px;
  margin-bottom: 16px;
  outline: none;
  transition: all 0.2s ease;
}

#room-name:focus {
  border-color: var(--border-focus);
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.button-group {
  display: flex;
  gap: 12px;
  margin-bottom: 20px;
}

#go-public {
  flex: 1;
  height: 48px;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

#go-public:hover {
  background: var(--primary-hover);
  transform: translateY(-1px);
}

#go-public:disabled {
  background: var(--text-light);
  cursor: not-allowed;
  transform: none;
}

.divider {
  margin: 20px 0;
  text-align: center;
  color: var(--text-light);
  font-size: 14px;
  position: relative;
}

.divider::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  height: 1px;
  background: var(--border-color);
  z-index: 1;
}

.divider span {
  background: var(--background);
  padding: 0 16px;
  position: relative;
  z-index: 2;
}

#go-private {
  width: 100%;
  height: 48px;
  background: transparent;
  color: var(--primary-color);
  border: 2px solid var(--primary-color);
  border-radius: 12px;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

#go-private:hover {
  background: var(--primary-color);
  color: white;
  transform: translateY(-1px);
}

#go-private:disabled {
  border-color: var(--text-light);
  color: var(--text-light);
  cursor: not-allowed;
  transform: none;
}

/* Status indicator */
.connection-status {
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 8px 16px;
  border-radius: 20px;
  font-size: 12px;
  font-weight: 500;
  z-index: 100;
  transition: all 0.2s ease;
}

.connection-status.connected {
  background: rgba(16, 185, 129, 0.1);
  color: var(--success-color);
  border: 1px solid rgba(16, 185, 129, 0.2);
}

.connection-status.connecting {
  background: rgba(245, 158, 11, 0.1);
  color: var(--warning-color);
  border: 1px solid rgba(245, 158, 11, 0.2);
}

.connection-status.disconnected {
  background: rgba(239, 68, 68, 0.1);
  color: var(--error-color);
  border: 1px solid rgba(239, 68, 68, 0.2);
}

/* Room info bar */
.room-info {
  position: fixed;
  top: 20px;
  left: 20px;
  right: 20px;
  background: var(--background);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 12px 16px;
  box-shadow: var(--shadow);
  z-index: 100;
  display: none;
  align-items: center;
  gap: 12px;
}

.room-info.visible {
  display: flex;
}

.room-info-content {
  flex: 1;
  min-width: 0;
}

.room-info h4 {
  margin: 0 0 4px 0;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-color);
}

.room-info p {
  margin: 0;
  font-size: 12px;
  color: var(--text-light);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.copy-button {
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 8px;
  padding: 6px 12px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.copy-button:hover {
  background: var(--primary-hover);
  transform: translateY(-1px);
}

.copy-button:active {
  transform: scale(0.95);
}

.copy-button.success {
  background: var(--success-color);
}

.close-room-info {
  background: none;
  border: none;
  color: var(--text-light);
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;
  font-size: 16px;
  line-height: 1;
}

.close-room-info:hover {
  background: var(--secondary-color);
  color: var(--text-color);
}

/* Mobile optimizations */
@media(max-width:768px) {
  #name-form-content,
  #room-form-content {
    padding: 30px 20px;
    margin: 20px;
  }
  
  #name-form h1 {
    font-size: 24px;
  }
  
  #room-form h2 {
    font-size: 20px;
  }
  
  #chatlog {
    padding: 15px;
    bottom: 70px;
  }
  
  #chatlog.with-room-info {
    top: 70px;
  }
  
  .button-group {
    flex-direction: column;
  }

  .connection-status {
    top: auto;
    bottom: 80px;
    right: 20px;
    left: auto;
  }

  .room-info {
    left: 10px;
    right: 10px;
    top: 10px;
  }

  .room-info p {
    font-size: 11px;
  }
}

@media(max-width:480px) {
  #name-form-content,
  #room-form-content {
    padding: 24px 16px;
    margin: 16px;
  }
  
  #chatlog {
    padding: 12px;
  }
  
  #chat-input-container {
    padding: 12px 16px;
  }

  .room-info {
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
  }

  .room-info-content {
    text-align: center;
  }

  .copy-button {
    width: 100%;
  }
}

/* Loading animation */
.loading {
  display: inline-block;
  width: 20px;
  height: 20px;
  border: 2px solid var(--border-color);
  border-radius: 50%;
  border-top-color: var(--primary-color);
  animation: spin 1s ease-in-out infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Message types */
.system-message {
  background: rgba(59, 130, 246, 0.1) !important;
  border-left: 4px solid var(--primary-color);
  font-style: italic;
}

.error-message {
  background: rgba(239, 68, 68, 0.1) !important;
  border-left: 4px solid var(--error-color);
  color: var(--error-color);
}

/* Turtle Soup styles */
.turtle-soup-btn {
  background: #16a34a;
  color: white;
  border: none;
  border-radius: 20px;
  padding: 8px 16px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-right: 12px;
  display: flex;
  align-items: center;
  gap: 4px;
}

.turtle-soup-btn:hover {
  background: #15803d;
  transform: translateY(-1px);
}

.turtle-soup-btn:disabled {
  background: var(--text-light);
  cursor: not-allowed;
  transform: none;
}

.turtle-soup-status {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(135deg, #16a34a, #15803d);
  color: white;
  padding: 12px 20px;
  border-radius: 12px;
  box-shadow: var(--shadow-lg);
  z-index: 200;
  animation: statusSlideIn 0.3s ease-out;
}

.turtle-soup-content {
  display: flex;
  align-items: center;
  gap: 12px;
  font-weight: 500;
}

.end-button {
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  padding: 4px 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.end-button:hover {
  background: rgba(255, 255, 255, 0.3);
}

@keyframes statusSlideIn {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

/* Turtle soup mode adjustments */
.turtle-soup-mode #chatlog {
  top: 100px;
}

.turtle-soup-mode #chatlog.with-room-info {
  top: 160px;
}

/* Turn indicator animations */
.turn-indicator-pulse {
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.1);
  }
  100% {
    transform: scale(1);
  }
}

/* Mobile optimizations for turtle soup */
@media(max-width:768px) {
  .turtle-soup-status {
    left: 10px;
    right: 10px;
    transform: none;
    top: 10px;
  }
  
  .turtle-soup-content {
    flex-direction: column;
    gap: 8px;
    text-align: center;
  }
  
  .turtle-soup-mode #chatlog {
    top: 90px;
  }
  
  .turtle-soup-mode #chatlog.with-room-info {
    top: 150px;
  }
}
</style>

<!--===================================================================================-->
<!-- The actual HTML. There is not much of it. -->

  </head>
  <body>
    <div class="connection-status connecting" id="connection-status">
      <span class="loading"></span> ËøûÊé•‰∏≠...
    </div>

    <div class="room-info" id="room-info">
      <div class="room-info-content">
        <h4 id="room-title">ÊàøÈó¥‰ø°ÊÅØ</h4>
        <p id="room-url">ÊàøÈó¥ÈìæÊé•</p>
      </div>
      <button id="copy-room-button" class="copy-button">üìã Â§çÂà∂ÈìæÊé•</button>
      <button class="close-room-info" onclick="hideRoomInfo()">‚úï</button>
    </div>

    <form id="name-form" action="/fake-form-action">
      <div id="name-form-content">
        <h1>üöÄ Edge Chat</h1>
        <input id="name-input" placeholder="ËØ∑ËæìÂÖ•‰Ω†ÁöÑÊòµÁß∞" maxlength="32">
        <p>ËøôÊòØ‰∏Ä‰∏™ËøêË°åÂú®ËæπÁºòËÆ°ÁÆóËäÇÁÇπ‰∏äÁöÑËÅäÂ§©Â∫îÁî®<br>
          Âü∫‰∫é <a href="https://blog.cloudflare.com/introducing-workers-durable-objects" target="_blank">Cloudflare Workers Durable Objects</a> ÊûÑÂª∫</p>
      </div>
    </form>

    <form id="room-form" action="/fake-form-action">
      <div id="room-form-content">
        <h2>ÈÄâÊã©ËÅäÂ§©ÂÆ§</h2>
        <input id="room-name" placeholder="ËæìÂÖ•ÊàøÈó¥ÂêçÁß∞" maxlength="32">
        <div class="button-group">
          <button type="button" id="go-public">Âä†ÂÖ•ÊàøÈó¥ ‚Üí</button>
        </div>
        <div class="divider">
          <span>ÊàñËÄÖ</span>
        </div>
        <button type="button" id="go-private">ÂàõÂª∫ÁßÅ‰∫∫ÊàøÈó¥ üîí</button>
      </div>
    </form>

    <form id="chatroom" action="/fake-form-action">
      <div id="chatlog">
        <div id="spacer"></div>
      </div>
      <div id="roster">
        <h3>Âú®Á∫øÁî®Êà∑</h3>
      </div>
      <div id="turtle-soup-status" class="turtle-soup-status" style="display: none;">
        <div class="turtle-soup-content">
          <span id="turn-indicator">üê¢</span>
          <span id="turn-text">Êµ∑ÈæüÊ±§ËøõË°å‰∏≠...</span>
          <button id="end-turtle-soup" class="end-button">ÁªìÊùüÊµ∑ÈæüÊ±§</button>
        </div>
      </div>
      <div id="chat-input-container">
        <button id="turtle-soup-button" class="turtle-soup-btn">üê¢ ÂèëËµ∑Êµ∑ÈæüÊ±§</button>
        <input id="chat-input" placeholder="ËæìÂÖ•Ê∂àÊÅØ..." maxlength="256">
        <button type="submit" id="send-button">üì§</button>
      </div>
    </form>
  </body>

<!--===================================================================================-->
<!-- Client-side JavaScript code for the app. -->

<script type="text/javascript">
let currentWebSocket = null;

let nameForm = document.querySelector("#name-form");
let nameInput = document.querySelector("#name-input");
let roomForm = document.querySelector("#room-form");
let roomNameInput = document.querySelector("#room-name");
let goPublicButton = document.querySelector("#go-public");
let goPrivateButton = document.querySelector("#go-private");
let chatroom = document.querySelector("#chatroom");
let chatlog = document.querySelector("#chatlog");
let chatInput = document.querySelector("#chat-input");
let roster = document.querySelector("#roster");
let connectionStatus = document.querySelector("#connection-status");
let sendButton = document.querySelector("#send-button");
let roomInfo = document.querySelector("#room-info");
let roomTitle = document.querySelector("#room-title");
let roomUrl = document.querySelector("#room-url");
let copyRoomButton = document.querySelector("#copy-room-button");
let turtleSoupButton = document.querySelector("#turtle-soup-button");
let turtleSoupStatus = document.querySelector("#turtle-soup-status");
let turnIndicator = document.querySelector("#turn-indicator");
let turnText = document.querySelector("#turn-text");
let endTurtleSoupButton = document.querySelector("#end-turtle-soup");

// Is the chatlog scrolled to the bottom?
let isAtBottom = true;

let username;
let roomname;

// Turtle Soup state management
let turtleSoupActive = false;
let turtleSoupParticipants = [];
let currentTurnIndex = 0;
let turtleSoupInitiator = null;
let pendingConfirmations = new Set();
let confirmationTimeout = null;
let hasResponded = false; // Track if user has already responded to current request

let hostname = window.location.host;
if (hostname == "") {
  // Probably testing the HTML locally.
  hostname = "edge-chat-demo.cloudflareworkers.com";
}

// Update connection status
function updateConnectionStatus(status, message) {
  connectionStatus.className = `connection-status ${status}`;
  connectionStatus.innerHTML = message;
}

// Show room info
function showRoomInfo() {
  const currentUrl = window.location.href;
  const isPrivateRoom = roomname.length === 64;
  
  roomTitle.textContent = isPrivateRoom ? "üîí ÁßÅ‰∫∫ÊàøÈó¥" : `üí¨ #${roomname}`;
  roomUrl.textContent = currentUrl;
  roomInfo.classList.add("visible");
  chatlog.classList.add("with-room-info");
}

// Hide room info
function hideRoomInfo() {
  roomInfo.classList.remove("visible");
  chatlog.classList.remove("with-room-info");
}

// Copy room URL to clipboard
async function copyRoomUrl() {
  try {
    await navigator.clipboard.writeText(window.location.href);
    
    // Show success feedback
    const originalText = copyRoomButton.innerHTML;
    copyRoomButton.innerHTML = "‚úÖ Â∑≤Â§çÂà∂!";
    copyRoomButton.classList.add("success");
    
    setTimeout(() => {
      copyRoomButton.innerHTML = originalText;
      copyRoomButton.classList.remove("success");
    }, 2000);
  } catch (err) {
    // Fallback for older browsers
    const textArea = document.createElement("textarea");
    textArea.value = window.location.href;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand('copy');
      copyRoomButton.innerHTML = "‚úÖ Â∑≤Â§çÂà∂!";
      copyRoomButton.classList.add("success");
      setTimeout(() => {
        copyRoomButton.innerHTML = "üìã Â§çÂà∂ÈìæÊé•";
        copyRoomButton.classList.remove("success");
      }, 2000);
    } catch (err) {
      copyRoomButton.innerHTML = "‚ùå Â§çÂà∂Â§±Ë¥•";
      setTimeout(() => {
        copyRoomButton.innerHTML = "üìã Â§çÂà∂ÈìæÊé•";
      }, 2000);
    }
    document.body.removeChild(textArea);
  }
}

function startNameChooser() {
  nameForm.addEventListener("submit", event => {
    event.preventDefault();
    username = nameInput.value.trim();
    if (username.length > 0) {
      startRoomChooser();
    }
  });

  nameInput.addEventListener("input", event => {
    if (event.currentTarget.value.length > 32) {
      event.currentTarget.value = event.currentTarget.value.slice(0, 32);
    }
  });

  // Auto-focus and better UX
  nameInput.focus();
  nameInput.addEventListener("keypress", event => {
    if (event.key === "Enter" && nameInput.value.trim().length > 0) {
      nameForm.dispatchEvent(new Event("submit"));
    }
  });
}

function startRoomChooser() {
  nameForm.style.display = "none";

  if (document.location.hash.length > 1) {
    roomname = document.location.hash.slice(1);
    startChat();
    return;
  }

  roomForm.addEventListener("submit", event => {
    event.preventDefault();
    roomname = roomNameInput.value.trim();
    if (roomname.length > 0) {
      startChat();
    }
  });

  roomNameInput.addEventListener("input", event => {
    if (event.currentTarget.value.length > 32) {
      event.currentTarget.value = event.currentTarget.value.slice(0, 32);
    }
  });

  goPublicButton.addEventListener("click", event => {
    roomname = roomNameInput.value.trim();
    if (roomname.length > 0) {
      startChat();
    }
  });

  goPrivateButton.addEventListener("click", async event => {
    // Disable buttons during request
    roomNameInput.disabled = true;
    goPublicButton.disabled = true;
    event.currentTarget.disabled = true;
    event.currentTarget.innerHTML = '<span class="loading"></span> ÂàõÂª∫‰∏≠...';

    try {
      let response = await fetch(window.location.protocol + "//" + hostname + "/api/room", {method: "POST"});
      if (!response.ok) {
        throw new Error('Failed to create room');
      }
      roomname = await response.text();
      startChat();
    } catch (error) {
      alert("ÂàõÂª∫ÊàøÈó¥Â§±Ë¥•ÔºåËØ∑ÈáçËØï");
      // Re-enable buttons
      roomNameInput.disabled = false;
      goPublicButton.disabled = false;
      event.currentTarget.disabled = false;
      event.currentTarget.innerHTML = "ÂàõÂª∫ÁßÅ‰∫∫ÊàøÈó¥ üîí";
    }
  });

  roomNameInput.focus();
  
  // Enter key support
  roomNameInput.addEventListener("keypress", event => {
    if (event.key === "Enter" && roomNameInput.value.trim().length > 0) {
      goPublicButton.click();
    }
  });
}

function startChat() {
  roomForm.style.display = "none";
  updateConnectionStatus("connecting", '<span class="loading"></span> ËøûÊé•‰∏≠...');

  // Normalize the room name a bit.
  roomname = roomname.replace(/[^a-zA-Z0-9_-]/g, "").replace(/_/g, "-").toLowerCase();

  if (roomname.length > 32 && !roomname.match(/^[0-9a-f]{64}$/)) {
    addChatMessage("ERROR", "ÊàøÈó¥ÂêçÊó†Êïà", true);
    return;
  }

  document.location.hash = "#" + roomname;

  // Show room info and setup copy functionality
  showRoomInfo();
  copyRoomButton.addEventListener("click", copyRoomUrl);

  chatInput.addEventListener("keydown", event => {
    if (event.keyCode == 38) {
      // up arrow
      chatlog.scrollBy(0, -50);
    } else if (event.keyCode == 40) {
      // down arrow
      chatlog.scrollBy(0, 50);
    } else if (event.keyCode == 33) {
      // page up
      chatlog.scrollBy(0, -chatlog.clientHeight + 50);
    } else if (event.keyCode == 34) {
      // page down
      chatlog.scrollBy(0, chatlog.clientHeight - 50);
    }
  });

  chatroom.addEventListener("submit", event => {
    event.preventDefault();
    sendMessage();
  });

  sendButton.addEventListener("click", event => {
    event.preventDefault();
    sendMessage();
  });

  // Turtle Soup button event listener
  turtleSoupButton.addEventListener("click", event => {
    event.preventDefault();
    initiateTurtleSoup();
  });

  // End Turtle Soup button event listener
  endTurtleSoupButton.addEventListener("click", event => {
    event.preventDefault();
    endTurtleSoup();
  });

  function sendMessage() {
    const message = chatInput.value.trim();
    if (currentWebSocket && message.length > 0) {
      // Check if turtle soup is active and it's the user's turn
      if (turtleSoupActive) {
        if (turtleSoupParticipants[currentTurnIndex] !== username) {
          addChatMessage(null, "‚ö†Ô∏è Áé∞Âú®‰∏çÊòØ‰Ω†ÁöÑÂèëË®ÄËΩÆÊ¨°ÔºåËØ∑Á≠âÂæÖ", true);
          return;
        }
        // Send message with turtle soup flag
        currentWebSocket.send(JSON.stringify({
          message: message,
          turtleSoupMessage: true,
          turnComplete: true
        }));
      } else {
        currentWebSocket.send(JSON.stringify({message: message}));
      }
      chatInput.value = "";
      // Scroll to bottom whenever sending a message.
      chatlog.scrollBy(0, 1e8);
    }
  }

  chatInput.addEventListener("input", event => {
    if (event.currentTarget.value.length > 256) {
      event.currentTarget.value = event.currentTarget.value.slice(0, 256);
    }
  });

  chatlog.addEventListener("scroll", event => {
    isAtBottom = chatlog.scrollTop + chatlog.clientHeight >= chatlog.scrollHeight - 5;
  });

  chatInput.focus();
  document.body.addEventListener("click", event => {
    // If the user clicked somewhere in the window without selecting any text, focus the chat input.
    if (window.getSelection().toString() == "" && !event.target.matches('button, input, a')) {
      chatInput.focus();
    }
  });

  // Detect mobile keyboard appearing and disappearing, and adjust the scroll as appropriate.
  if('visualViewport' in window) {
    window.visualViewport.addEventListener('resize', function(event) {
      if (isAtBottom) {
        chatlog.scrollBy(0, 1e8);
      }
    });
  }

  join();
}

let lastSeenTimestamp = 0;
let wroteWelcomeMessages = false;

function join() {
  // If we are running via wrangler dev, use ws:
  const wss = document.location.protocol === "http:" ? "ws://" : "wss://";
  let ws = new WebSocket(wss + hostname + "/api/room/" + roomname + "/websocket");
  let rejoined = false;
  let startTime = Date.now();

  let rejoin = async () => {
    if (!rejoined) {
      rejoined = true;
      currentWebSocket = null;
      updateConnectionStatus("disconnected", "‚ùå ËøûÊé•Êñ≠ÂºÄ");

      // Clear the roster.
      const rosterHeader = roster.querySelector('h3');
      roster.innerHTML = '';
      roster.appendChild(rosterHeader);

      // Don't try to reconnect too rapidly.
      let timeSinceLastJoin = Date.now() - startTime;
      if (timeSinceLastJoin < 10000) {
        // Less than 10 seconds elapsed since last join. Pause a bit.
        updateConnectionStatus("connecting", '<span class="loading"></span> ÈáçÊñ∞ËøûÊé•‰∏≠...');
        await new Promise(resolve => setTimeout(resolve, 10000 - timeSinceLastJoin));
      }

      // OK, reconnect now!
      join();
    }
  }

  ws.addEventListener("open", event => {
    currentWebSocket = ws;
    updateConnectionStatus("connected", "‚úÖ Â∑≤ËøûÊé•");
    // Send user info message.
    ws.send(JSON.stringify({name: username}));
  });

  ws.addEventListener("message", event => {
    let data = JSON.parse(event.data);

    if (data.error) {
      addChatMessage(null, "‚ùå ÈîôËØØ: " + data.error, true);
    } else if (data.joined) {
      // Check if user is already in the roster to avoid duplicates
      let userExists = false;
      for (let child of roster.childNodes) {
        if (child.innerText === data.joined) {
          userExists = true;
          break;
        }
      }
      
      // Only add if user doesn't already exist in roster
      if (!userExists) {
        let p = document.createElement("p");
        p.innerText = data.joined;
        roster.appendChild(p);
      }
    } else if (data.quit) {
      for (let child of roster.childNodes) {
        if (child.innerText == data.quit) {
          roster.removeChild(child);
          break;
        }
      }
    } else if (data.ready) {
      // All pre-join messages have been delivered.
      if (!wroteWelcomeMessages) {
        wroteWelcomeMessages = true;
        addChatMessage(null,
            "üéâ Ê¨¢ËøéÊù•Âà∞Âü∫‰∫é Cloudflare Workers Durable Objects ÊûÑÂª∫ÁöÑËÅäÂ§©ÂÆ§ÔºÅÊ∫ê‰ª£Á†Å: https://github.com/cloudflare/workers-chat-demo", true);
        addChatMessage(null,
            "‚ö†Ô∏è Ë≠¶Âëä: ËÅäÂ§©ÂÆ§‰∏≠ÁöÑÂèÇ‰∏éËÄÖÊòØÊù•Ëá™‰∫íËÅîÁΩëÁöÑÈöèÊú∫Áî®Êà∑„ÄÇÁî®Êà∑ÂêçÊú™ÁªèÈ™åËØÅÔºõ‰ªª‰Ωï‰∫∫ÈÉΩÂèØ‰ª•ÂÜíÂÖÖ‰ªñ‰∫∫„ÄÇËÅäÂ§©ËÆ∞ÂΩï‰ºöË¢´‰øùÂ≠ò„ÄÇ", true);
        if (roomname.length == 64) {
          addChatMessage(null,
              "üîí ËøôÊòØ‰∏Ä‰∏™ÁßÅ‰∫∫ÊàøÈó¥„ÄÇ‰Ω†ÂèØ‰ª•ÈÄöËøáÁÇπÂáª‰∏äÊñπÁöÑÂ§çÂà∂ÊåâÈíÆÂàÜ‰∫´ÊàøÈó¥ÈìæÊé•ÈÇÄËØ∑ÂÖ∂‰ªñ‰∫∫Âä†ÂÖ•„ÄÇ", true);
        } else {
          addChatMessage(null,
              "üëã Ê¨¢ËøéÊù•Âà∞ #" + roomname + " ÊàøÈó¥ÔºåÂºÄÂßãËÅäÂ§©ÂêßÔºÅ‰Ω†ÂèØ‰ª•ÁÇπÂáª‰∏äÊñπÁöÑÂ§çÂà∂ÊåâÈíÆÂàÜ‰∫´ÊàøÈó¥ÈìæÊé•„ÄÇ", true);
        }
      }
    } else if (data.turtleSoupRequest) {
      // Handle turtle soup initiation request
      handleTurtleSoupRequest(data);
    } else if (data.turtleSoupConfirm) {
      // Handle turtle soup confirmation
      handleTurtleSoupConfirmation(data);
    } else if (data.turtleSoupStart) {
      // Handle turtle soup start
      handleTurtleSoupStart(data);
    } else if (data.turtleSoupTurnChange) {
      // Handle turn change
      handleTurnChange(data);
    } else if (data.turtleSoupEnd) {
      // Handle turtle soup end
      handleTurtleSoupEnd(data);
    } else {
      // A regular chat message.
      if (data.timestamp > lastSeenTimestamp) {
        addChatMessage(data.name, data.message);
        lastSeenTimestamp = data.timestamp;
        
        // If this is a turtle soup message, handle turn change
        if (data.turtleSoupMessage && turtleSoupActive) {
          handleTurtleSoupTurnComplete(data);
        }
      }
    }
  });

  ws.addEventListener("close", event => {
    console.log("WebSocket closed, reconnecting:", event.code, event.reason);
    rejoin();
  });
  
  ws.addEventListener("error", event => {
    console.log("WebSocket error, reconnecting:", event);
    rejoin();
  });
}

function addChatMessage(name, text, isSystem = false) {
  let p = document.createElement("p");
  
  if (isSystem) {
    p.className = "system-message";
  }
  
  if (name) {
    let tag = document.createElement("span");
    tag.className = "username";
    tag.innerText = name + ": ";
    p.appendChild(tag);
  }
  
  p.appendChild(document.createTextNode(text));

  // Append the new chat line, making sure that if the chatlog was scrolled to the bottom
  // before, it remains scrolled to the bottom, and otherwise the scroll position doesn't change.
  chatlog.appendChild(p);
  if (isAtBottom) {
    setTimeout(() => chatlog.scrollBy(0, 1e8), 10);
  }
}

// Turtle Soup Functions
function initiateTurtleSoup() {
  console.log(`[TurtleSoup Client] ${username} initiating turtle soup`);
  
  if (turtleSoupActive) {
    addChatMessage(null, "‚ö†Ô∏è Êµ∑ÈæüÊ±§Â∑≤ÁªèËøõË°å‰∏≠", true);
    return;
  }
  
  // Check if already waiting for confirmations
  if (turtleSoupButton.disabled) {
    console.log(`[TurtleSoup Client] Already waiting for confirmations, ignoring duplicate request`);
    return;
  }
  
  // Get all online users from roster
  const onlineUsers = [];
  for (let child of roster.childNodes) {
    if (child.innerText && child.innerText.trim() !== 'Âú®Á∫øÁî®Êà∑') {
      onlineUsers.push(child.innerText.trim());
    }
  }
  
  console.log(`[TurtleSoup Client] Found online users:`, onlineUsers);
  
  if (onlineUsers.length < 2) {
    addChatMessage(null, "‚ö†Ô∏è ÈúÄË¶ÅËá≥Â∞ë2‰∫∫ÊâçËÉΩÂèëËµ∑Êµ∑ÈæüÊ±§", true);
    return;
  }
  
  // Disable button and send request
  turtleSoupButton.disabled = true;
  turtleSoupButton.textContent = "Á≠âÂæÖÁ°ÆËÆ§...";
  
  // Send turtle soup request - let server determine participants
  if (currentWebSocket) {
    currentWebSocket.send(JSON.stringify({
      turtleSoupRequest: true,
      initiator: username,
      participants: onlineUsers  // Send what we see, but server will use its own list
    }));
    console.log(`[TurtleSoup Client] Sent request with participants:`, onlineUsers);
  }
  
  // Set timeout for confirmations
  confirmationTimeout = setTimeout(() => {
    console.log(`[TurtleSoup Client] Request timeout`);
    addChatMessage(null, "‚è∞ Êµ∑ÈæüÊ±§ÂèëËµ∑Ë∂ÖÊó∂ÔºåËØ∑ÈáçÊñ∞Â∞ùËØï", true);
    resetTurtleSoupButton();
  }, 30000); // 30 seconds timeout
}

function handleTurtleSoupRequest(data) {
  console.log(`[TurtleSoup Client] Received request from ${data.initiator}, participants:`, data.participants);
  
  if (data.initiator === username) {
    // This is our own request, ignore
    console.log(`[TurtleSoup Client] Ignoring own request`);
    return;
  }
  
  // Check if already responded to this initiator's request
  if (hasResponded) {
    console.log(`[TurtleSoup Client] Already responded to request, ignoring duplicate`);
    return;
  }
  
  // Show confirmation dialog
  const confirmStart = confirm(`${data.initiator} ÂèëËµ∑‰∫ÜÊµ∑ÈæüÊ±§ÔºåÊòØÂê¶ÂèÇ‰∏éÔºü\nÂèÇ‰∏éËÄÖ: ${data.participants.join(', ')}`);
  console.log(`[TurtleSoup Client] User ${username} confirmed: ${confirmStart}`);
  
  // Mark as responded
  hasResponded = true;
  
  if (currentWebSocket) {
    currentWebSocket.send(JSON.stringify({
      turtleSoupConfirm: true,
      initiator: data.initiator,
      confirmed: confirmStart,
      user: username
    }));
    console.log(`[TurtleSoup Client] Sent confirmation response`);
  }
}

function handleTurtleSoupConfirmation(data) {
  console.log(`[TurtleSoup Client] Confirmation from ${data.user}: ${data.confirmed}`);
  
  if (data.confirmed) {
    addChatMessage(null, `‚úÖ ${data.user} Á°ÆËÆ§ÂèÇ‰∏éÊµ∑ÈæüÊ±§`, true);
  } else {
    addChatMessage(null, `‚ùå ${data.user} ÊãíÁªùÂèÇ‰∏éÊµ∑ÈæüÊ±§`, true);
    hasResponded = false; // Reset for next request
    // Cancel the turtle soup if we are the initiator
    if (data.initiator === username) {
      console.log(`[TurtleSoup Client] Canceling due to rejection`);
      if (confirmationTimeout) {
        clearTimeout(confirmationTimeout);
      }
      resetTurtleSoupButton();
    }
  }
}

function handleTurtleSoupStart(data) {
  console.log(`[TurtleSoup Client] Starting turtle soup with participants:`, data.participants);
  
  turtleSoupActive = true;
  turtleSoupParticipants = data.participants;
  currentTurnIndex = 0;
  turtleSoupInitiator = data.initiator;
  hasResponded = false; // Reset for next request
  
  // Clear confirmation timeout for everyone (not just initiator)
  if (confirmationTimeout) {
    console.log(`[TurtleSoup Client] Clearing confirmation timeout`);
    clearTimeout(confirmationTimeout);
    confirmationTimeout = null;
  }
  
  // Update UI
  document.body.classList.add('turtle-soup-mode');
  turtleSoupStatus.style.display = 'block';
  turtleSoupButton.style.display = 'none';
  
  updateTurnDisplay();
  addChatMessage(null, `üê¢ Êµ∑ÈæüÊ±§ÂºÄÂßãÔºÅÂèÇ‰∏éËÄÖ: ${turtleSoupParticipants.join(', ')}`, true);
  addChatMessage(null, `ËßÑÂàô: ‰∏Ä‰∫∫‰∏ÄÂè•ËØùËΩÆÊµÅÂèëË®ÄÔºåÂèëÂÆåË®ÄËá™Âä®ËΩÆÂà∞‰∏ã‰∏Ä‰∏™‰∫∫`, true);
  
  console.log(`[TurtleSoup Client] Turtle soup UI updated successfully`);
}

function handleTurnChange(data) {
  currentTurnIndex = data.turnIndex;
  updateTurnDisplay();
}

function handleTurtleSoupEnd(data) {
  endTurtleSoupMode();
  addChatMessage(null, `üèÅ Êµ∑ÈæüÊ±§ÁªìÊùüÔºåÊÑüË∞¢ÂèÇ‰∏éÔºÅ`, true);
}

function handleTurtleSoupTurnComplete(data) {
  if (data.name === turtleSoupParticipants[currentTurnIndex]) {
    // Move to next participant
    currentTurnIndex = (currentTurnIndex + 1) % turtleSoupParticipants.length;
    
    // Broadcast turn change
    if (currentWebSocket && username === turtleSoupInitiator) {
      currentWebSocket.send(JSON.stringify({
        turtleSoupTurnChange: true,
        turnIndex: currentTurnIndex,
        nextPlayer: turtleSoupParticipants[currentTurnIndex]
      }));
    }
    
    updateTurnDisplay();
  }
}

function updateTurnDisplay() {
  if (!turtleSoupActive) return;
  
  const currentPlayer = turtleSoupParticipants[currentTurnIndex];
  
  if (currentPlayer === username) {
    turnText.textContent = "ËΩÆÂà∞‰Ω†ÂèëË®Ä";
    turnIndicator.className = "turn-indicator-pulse";
    chatInput.placeholder = "ËæìÂÖ•‰Ω†ÁöÑÂèëË®Ä...";
    chatInput.disabled = false;
  } else {
    turnText.textContent = `ËΩÆÂà∞ ${currentPlayer} ÂèëË®Ä`;
    turnIndicator.className = "";
    chatInput.placeholder = `Á≠âÂæÖ ${currentPlayer} ÂèëË®Ä...`;
    chatInput.disabled = true;
  }
}

function endTurtleSoup() {
  if (!turtleSoupActive) return;
  
  if (username !== turtleSoupInitiator) {
    addChatMessage(null, "‚ö†Ô∏è Âè™ÊúâÂèëËµ∑‰∫∫ÂèØ‰ª•ÁªìÊùüÊµ∑ÈæüÊ±§", true);
    return;
  }
  
  // Broadcast end message
  if (currentWebSocket) {
    currentWebSocket.send(JSON.stringify({
      turtleSoupEnd: true,
      initiator: username
    }));
  }
  
  endTurtleSoupMode();
}

function endTurtleSoupMode() {
  turtleSoupActive = false;
  turtleSoupParticipants = [];
  currentTurnIndex = 0;
  turtleSoupInitiator = null;
  pendingConfirmations.clear();
  
  // Update UI
  document.body.classList.remove('turtle-soup-mode');
  turtleSoupStatus.style.display = 'none';
  turtleSoupButton.style.display = 'block';
  chatInput.disabled = false;
  chatInput.placeholder = "ËæìÂÖ•Ê∂àÊÅØ...";
  
  resetTurtleSoupButton();
}

function resetTurtleSoupButton() {
  turtleSoupButton.disabled = false;
  turtleSoupButton.textContent = "üê¢ ÂèëËµ∑Êµ∑ÈæüÊ±§";
  hasResponded = false; // Reset for next request
  
  if (confirmationTimeout) {
    clearTimeout(confirmationTimeout);
    confirmationTimeout = null;
  }
}

// Initialize the app
updateConnectionStatus("connecting", '<span class="loading"></span> ÂàùÂßãÂåñ‰∏≠...');
startNameChooser();
</script>
<!--===================================================================================-->
</html>